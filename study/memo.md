# 自主学習

記事とかで読んだ内容でメモしといたほうが良さそうなものをピックアップ

## helm とは

Kubernetes 用のパッケージマネージャ

「Kubernetes 用のパッケージ」とは「1 つのアプリケーション(業務システム)としての動作を行う為に必要な Kubernetes の様々な種類のリソース(Deployment, Service, Ingress, Secret, ConfigMap, PersistentVolume, … など)」である

それをひとまとめにして管理する仕組みと、そのためのツールセットを提供するもの

### helm のパッケージマネージャーとしての性質

- 自分の Kubernetes クラスター環境へのデプロイ(インストール)・削除(アンインストール)
- パッケージを共有する仕組み(リポジトリ)
- 新規のパッケージを開発する支援機能

### helm の登場背景

1. コンテナ技術(Docker)が登場した。
2. 大量のコンテナのインフラ管理のための仕組みが必要になり、Kubernetes というコンテナオーケストレーション基盤と位置づけられるソフトウェアが登場した。
3. 次はその基盤上で、Kubernetes のリソース群を効率良く、アプリケーションという論理的な単位で扱えるパッケージマネージャが必要になった。→ Helm の登場

メリットの一例としてアプリのアンインストールが簡単に行える。具体的には、作成された大量の Kubernetes リソースを一括で整合性をもって削除できる

### helm の構成要素

01 フォルダを参考にする

## helm 理解の補足

よくわかってなかったやつ、忘れかけてるものを羅列

- Helm チャートリポジトリ内の情報(どのような名前・バージョンのチャートが登録されているか)、は、Helm クライアント側でキャッシュしています。最新のそのリポジトリ内の情報を得るには、helm repo update コマンドを実行して、再度取得してキャッシュをリフレッシュする必要があります。

- index.yaml とチャートの.tgz ファイルが HTTP(または HTTPS)でサービスされる URL が Helm チャートリポジトリである

- Helm チャートを実際にその Kubernetes クラスターにデプロイしたら、そのインストールによってデプロイされた構成全体を意味する定義が作成される。これを「リリース」という。

- helm クライアント環境において、チャートがある場所がまだ認識済みでないリポジトリであれば、その Helm チャートリポジトリの URL を登録(helm repo add コマンド)して、Helm クライアント環境がチャートの検索先として認識出来るようにします

この記事の存在意義の否定になってしまうかもしれませんが、チャートの開発は、既存の公式チャートの中身を見ることが最良の学習手段といえます。

### chart の構造

```
<チャート名ディレクトリ>/
  Chart.yaml          # チャートの概要が記述されたYAMLファイル(ファイル名は予約)
  LICENSE             # オプション:このチャートのライセンス情報
  README.md           # オプション: チャートの説明
  requirements.yaml   # オプション: このチャートが利用する(依存する)他のチャートの一覧。(ファイル名は予約)
  values.yaml         # このチャートのデフォルト設定値が定義されたYAMLファイル。ファイル名は予約)
  charts/             # このチャートが依存するチャートをコピー配置するディレクトリ(ディレクトリ名は予約)
  templates/          # チャートの本体ともいえる、KubernetesオブジェクトのリソースYAMLのテンプレート群を配置するディレクトリ(ディレクトリ名は予約)
  templates/NOTES.txt # オプション:利用方法を生成するテキストファイル
  tests/              # オプション:helm testで実行されるテスト用YAMLを配置するディレクトリ(ディレクトリ名は予約)
```

上記の Chart.yaml、requirementes.yaml, values.yaml そして templates ディレクトリはまずはそのファイル名と役割は理解しておくことが何よりも必要なこと

このディレクトリ構造の雛形は、`helm create <チャート名>` コマンドで作成することができる。コマンドを実行すると、カレントディレクトリに指定したチャート名のディレクトリが作成され、その中に予約ファイル群が作成されるので、書き換えて利用

### Helm チャートの設計と作成

1. 再利用する(再利用可能な)Helm チャートの検討
   - 自分の作成したいアプリケーション全体を考えて、既存のチャートでまかなえるのかどうか考える
2. 自チャート内で必要な Kubernetes オブジェクト(リソース)の決定
   - まずは 1 つ 1 つ、通常の手順でリソース定義の YAML ファイルを作成し、kubectl apply コマンドでリソースを作成し、“意図通りに動く状態”を構築・確認したあとで、それらの定義を元に、テンプレート化するのがよし
3. チャートの可変パラメータ部分のデフォルト値の決定
   - 全部パラメータ化するのは時間と労力的に面倒なので、「ここはパラメータ化しておいたほうが良いだろう」というところを識別しつつ、同時にそのパラメータのデフォルト値を考える
4. チャートの公開手段と場所の決定
   - 作成するチャートをどのように利用者に公開するのかを検討するべし。以下の 3 つのパターンが有る。
     - ディレクトリを共有する(Git リポジトリで共有)
     - 共有ファイルサーバーに.tgz ファイルを置いておく
     - helm リポジトリを構築する(Helm リポジトリを構築すれば各チャートのバージョン(リビジョン)管理を helm クライアントが認識し、利用者にとって管理しやすいというメリット)
5. チャートの作成とテスト
   - helm lint
   - helm install で実際にデプロイして動作テスト

## chart の作り方の流れ

0. subchart が必要な場合は準備
   - requirements.yaml を準備
   - helm dependency update することで charts ディレクトリーはいかにダウンロードされる
1. template 化
   - kubernetes リソースの template 化
   - values.yaml の作成
2. NOTES.txt の作成
3. helm lint による静的解析
4. helm test によるテスト
   - test 用の yaml ファイルが必要なので、複雑なチャート構成でなければ、この機能を使うまでもなく、動作テストを行ったほうが良い
5. chart のパッケージ
   - chart.yaml の編集
   - helm package コマンドで tar ボールに詰める
   - helm repo index コマンドで inex.yaml を作成
6. chart リポジトリーへの公開
   - helm repo add して chart リポジトリを追加
   - helm repo update でこちらのリポジトリを更新

## 参考

- [Helm の概要と Chart(チャート)の作り方](https://qiita.com/thinksphere/items/5f3e918015cf4e63a0bc)
